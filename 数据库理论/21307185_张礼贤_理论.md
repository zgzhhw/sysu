1. **外连接表达式可以在SQL中不使用SQL outer join操作来计算。为了说明这一点，展示如何重写以下SQL查询而不使用外连接表达式：select * from student natural left outer join takes**


    * ```sql
        -- 内连接获取共有记录
        select *
        from student s inner join takes t on s.ID = t.ID

        -- UNION操作获取student表中有而takes表中没有的记录
        union all

        select ID, name, dept_name, tot_credID, null as course_id, null as sec_id, null as semester, null as year, null as grade
        from student s
        where s.ID not in (select ID from takes);
      ```


    * ```sql
        -- 内连接获取共有记录
        select s.*
        from student s inner join takes t on s.ID=t.ID

        union

        select ID, name, dept_name, tot_credID, null as course_id, null as sec_id, null as semester, null as year, null as grade
        from student
        where ID not in (select ID from takes)

        union

        select ID, null as name, null as dept_name, null as tot_credID, course_id, sec_id, semester, year, grade
        from takes
        where ID not in (select ID from student)
      ```

---

2. **SQL允许外键依赖引用相同的关系，如以下示例中所示：**
    ```sql
    create table manager
    (employee ID char(20),
    manager ID char(20),
    primary key employee ID,
    foreign key (manager ID) references manager(employee ID)
    on delete cascade );
    ```


* 在给定的SQL表格定义中，`manager`表中的每个元组都包含两个字段：`employee ID`（作为主键）和`manager ID`（作为外键，引用同一个表中的`employee ID`）。这种设计意味着每个员工都可以是另一个员工的经理，而且每个经理也必须是一名员工。考虑到这个结构，当`manager`表中的某个元组被删除时，发生以下事情：

    1. **级联删除（Cascade Delete）**：由于外键约束中包含`ON DELETE CASCADE`子句，当`manager`表中的某个员工的记录被删除时，与之相关联的所有经理记录也会被自动删除。这确保了不会在`manager`表中留下指向不存在员工的经理记录。

    2. **完整性检查**：在删除任何`manager`表中的记录之前，数据库系统会检查`manager ID`字段的值是否在`employee ID`字段中有对应的匹配。如果没有匹配，删除操作将被拒绝，以保持外键约束的完整性。

    3. **主键不受影响**：由于`employee ID`字段是主键，删除经理记录不会影响其他`manager`表中的元组。只有包含被删除员工的`manager ID`的记录会受到影响。

    因此，当`manager`表中的某个元组被删除时，具有相应`manager ID`的所有记录都会被级联删除，同时保持主键和外键的完整性。

---

3. **定义一个名为"tot_credits"的视图（year, num_credits），该视图显示每年所修的总学分数**
    ```sql
    create view tot_credits as
    select sec.year, sum(cr.credits)
    from section sec join course cr on sec.course_id = cr.course_id
    group by sec.year
    ```

---

4. **请表达以下查询的SQL，不使用子查询和集合操作（参考fig 1）**
    ```sql
    select s.ID
    from students s, advisor a
    where s.ID = a.s_id and a.i_id is null
    ```

---

5. **重新编写查询，使用内连接和使用"using"条件来代替"natural join"（参考fig1）**
    ```sql
    select *
    from section inner join classroom using (building, room_number);
    ```